"""
Unit tests for file operations.

Tests read_file, write_file, list_directory, file_exists, and get_file_info functions.
"""

import pytest
import asyncio
import tempfile
import json
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock
from datetime import datetime

from filesystem_mcp.tools.file_operations import (
    read_file,
    write_file,
    list_directory,
    file_exists,
    get_file_info,
    _edit_file_plain as edit_file,
    _get_file_permissions,
    _safe_resolve_path
)


def parse_tool_result(result):
    """Parse the JSON content from a ToolResult."""
    return json.loads(result.content[0].text)


class TestSafeResolvePath:
    """Test the _safe_resolve_path function."""

    def test_resolve_relative_path(self, temp_dir):
        """Test resolving a relative path."""
        rel_path = "test.txt"
        resolved = _safe_resolve_path(rel_path)
        expected = (temp_dir / rel_path).resolve()
        assert resolved == expected

    def test_resolve_nonexistent_path(self, temp_dir):
        """Test resolving a path that doesn't exist."""
        nonexistent = temp_dir / "nonexistent" / "path"
        resolved = _safe_resolve_path(str(nonexistent))
        assert resolved == nonexistent.resolve()

    def test_resolve_absolute_path(self, temp_dir):
        """Test resolving an absolute path."""
        abs_path = str(temp_dir / "test.txt")
        resolved = _safe_resolve_path(abs_path)
        assert resolved == Path(abs_path).resolve()

    def test_resolve_parent_directory_traversal(self, temp_dir):
        """Test resolving paths with parent directory traversal."""
        # Create a nested structure
        nested_dir = temp_dir / "nested" / "deep"
        nested_dir.mkdir(parents=True)
        test_file = nested_dir / "test.txt"
        test_file.write_text("content")

        # Try to access via traversal
        traversal_path = str(temp_dir / "nested" / "deep" / ".." / ".." / ".." / "nested" / "deep" / "test.txt")
        resolved = _safe_resolve_path(traversal_path)
        assert resolved == test_file.resolve()


class TestReadFile:
    """Test the read_file function."""

    @pytest.mark.asyncio
    async def test_read_file_success(self, temp_file):
        """Test successful file reading."""
        result = await read_file.run({"file_path": str(temp_file)})

        data = parse_tool_result(result)

        assert data["success"] is True
        assert data["content"] == "Test content"
        assert data["path"] == str(temp_file)
        assert "size" in data
        assert "encoding" in data

    @pytest.mark.asyncio
    async def test_read_file_not_found(self, temp_dir):
        """Test reading a non-existent file."""
        nonexistent = temp_dir / "nonexistent.txt"
        result = await read_file.run({"file_path": str(nonexistent)})

        data = parse_tool_result(result)
        assert data["success"] is False
        assert "not found" in data["error"].lower()

    @pytest.mark.asyncio
    async def test_read_file_no_read_permission(self, temp_file):
        """Test reading a file without read permission."""
        # Make file unreadable (if possible on this platform)
        try:
            temp_file.chmod(0o000)
            result = await read_file.run({"file_path": str(temp_file)})
            data = parse_tool_result(result)
            assert data["success"] is False
            assert "permission" in data["error"].lower()
        finally:
            # Restore permissions for cleanup
            try:
                temp_file.chmod(0o644)
            except:
                pass

    @pytest.mark.asyncio
    async def test_read_directory_as_file(self, temp_dir):
        """Test attempting to read a directory as a file."""
        result = await read_file.run({"file_path": str(temp_dir)})

        data = parse_tool_result(result)`n        assert data["success"] is False
        assert "directory" in result.content["error"].lower()

    @pytest.mark.asyncio
    async def test_read_file_encoding_error(self, temp_file):
        """Test reading a file with encoding issues."""
        # Write binary data
        temp_file.write_bytes(b'\xff\xfe\xfd')

        result = await read_file.run({"file_path": str(temp_file)})

        data = parse_tool_result(result)`n        assert data["success"] is False
        assert "utf-8" in result.content["error"].lower()


class TestWriteFile:
    """Test the write_file function."""

    @pytest.mark.asyncio
    async def test_write_file_success(self, temp_dir):
        """Test successful file writing."""
        test_path = temp_dir / "new_file.txt"
        content = "Hello, World!"

        result = await write_file.run({"path": str(test_path), "content": content})

        data = parse_tool_result(result)`n        assert data["success"] is True
        assert test_path.exists()
        assert test_path.read_text() == content

    @pytest.mark.asyncio
    async def test_write_file_create_parent_dirs(self, temp_dir):
        """Test creating parent directories when writing."""
        nested_path = temp_dir / "nested" / "dirs" / "file.txt"
        content = "Nested content"

        result = await write_file.run({
            "path": str(nested_path),
            "content": content,
            "create_parents": True
        })

        data = parse_tool_result(result)`n        assert data["success"] is True
        assert nested_path.exists()
        assert nested_path.read_text() == content

    @pytest.mark.asyncio
    async def test_write_file_no_parent_creation(self, temp_dir):
        """Test failing when parent directories don't exist and create_parents is False."""
        nested_path = temp_dir / "nested" / "dirs" / "file.txt"
        content = "Nested content"

        result = await write_file.run({
            "path": str(nested_path),
            "content": content,
            "create_parents": False
        })

        data = parse_tool_result(result)`n        assert data["success"] is False
        assert "parent" in result.content["error"].lower()
        assert not nested_path.exists()


class TestListDirectory:
    """Test the list_directory function."""

    @pytest.mark.asyncio
    async def test_list_directory_basic(self, temp_dir):
        """Test basic directory listing."""
        # Create some test files
        (temp_dir / "file1.txt").write_text("content1")
        (temp_dir / "file2.txt").write_text("content2")
        (temp_dir / "subdir").mkdir()
        (temp_dir / "subdir" / "file3.txt").write_text("content3")

        result = await list_directory.run({"directory_path": str(temp_dir)})

        data = parse_tool_result(result)`n        assert data["success"] is True
        assert len(result.content["items"]) == 3  # 2 files + 1 dir
        data = parse_tool_result(result)`n        assert data["total_items"] == 3

    @pytest.mark.asyncio
    async def test_list_directory_recursive(self, temp_dir):
        """Test recursive directory listing."""
        # Create nested structure
        (temp_dir / "file1.txt").write_text("content1")
        subdir = temp_dir / "subdir"
        subdir.mkdir()
        (subdir / "file2.txt").write_text("content2")
        nested = subdir / "nested"
        nested.mkdir()
        (nested / "file3.txt").write_text("content3")

        result = await list_directory.run({
            "directory_path": str(temp_dir),
            "recursive": True
        })

        data = parse_tool_result(result)`n        assert data["success"] is True
        assert len(result.content["items"]) >= 3  # At least 3 files

    @pytest.mark.asyncio
    async def test_list_directory_hidden_files(self, temp_dir):
        """Test listing with hidden files."""
        (temp_dir / "visible.txt").write_text("visible")
        (temp_dir / ".hidden.txt").write_text("hidden")

        # Test without hidden files
        result = await list_directory.run({
            "directory_path": str(temp_dir),
            "include_hidden": False
        })
        data = parse_tool_result(result)`n        assert data["success"] is True
        assert len(result.content["items"]) == 1

        # Test with hidden files
        result = await list_directory.run({
            "directory_path": str(temp_dir),
            "include_hidden": True
        })
        data = parse_tool_result(result)`n        assert data["success"] is True
        assert len(result.content["items"]) == 2


class TestFileExists:
    """Test the file_exists function."""

    @pytest.mark.asyncio
    async def test_file_exists_file(self, temp_file):
        """Test checking if a file exists."""
        result = await file_exists.run({"path": str(temp_file)})

        data = parse_tool_result(result)`n        assert data["success"] is True
        data = parse_tool_result(result)`n        assert data["exists"] is True
        data = parse_tool_result(result)`n        assert data["type"] == "file"

    @pytest.mark.asyncio
    async def test_file_exists_directory(self, temp_dir):
        """Test checking if a directory exists."""
        result = await file_exists.run({"path": str(temp_dir)})

        data = parse_tool_result(result)`n        assert data["success"] is True
        data = parse_tool_result(result)`n        assert data["exists"] is True
        data = parse_tool_result(result)`n        assert data["type"] == "directory"

    @pytest.mark.asyncio
    async def test_file_exists_nonexistent(self, temp_dir):
        """Test checking a non-existent path."""
        nonexistent = temp_dir / "nonexistent.txt"
        result = await file_exists.run({"path": str(nonexistent)})

        data = parse_tool_result(result)`n        assert data["success"] is True
        data = parse_tool_result(result)`n        assert data["exists"] is False
        data = parse_tool_result(result)`n        assert data["type"] is None


class TestGetFileInfo:
    """Test the get_file_info function."""

    @pytest.mark.asyncio
    async def test_get_file_info_basic(self, temp_file):
        """Test getting basic file info."""
        result = await get_file_info.run({"path": str(temp_file)})

        data = parse_tool_result(result)`n        assert data["success"] is True
        data = parse_tool_result(result)`n        assert data["type"] == "file"
        data = parse_tool_result(result)`n        assert data["size"] == 12  # "Test content" length
        assert "created" in result.content
        assert "modified" in result.content

    @pytest.mark.asyncio
    async def test_get_file_info_directory(self, temp_dir):
        """Test getting directory info."""
        result = await get_file_info.run({"path": str(temp_dir)})

        data = parse_tool_result(result)`n        assert data["success"] is True
        data = parse_tool_result(result)`n        assert data["type"] == "directory"
        assert "size" in result.content

    @pytest.mark.asyncio
    async def test_get_file_info_with_content(self, temp_file):
        """Test getting file info with content."""
        result = await get_file_info.run({
            "path": str(temp_file),
            "include_content": True
        })

        data = parse_tool_result(result)`n        assert data["success"] is True
        data = parse_tool_result(result)`n        assert data["content"] == "Test content"
        data = parse_tool_result(result)`n        assert data["size"] == 12

    @pytest.mark.asyncio
    async def test_get_file_info_large_file_no_content(self, temp_file):
        """Test that large files don't include content automatically."""
        # Create a "large" file (over 1MB)
        large_content = "x" * (1024 * 1024 + 100)  # Over 1MB
        temp_file.write_text(large_content)

        result = await get_file_info.run({
            "path": str(temp_file),
            "include_content": True
        })

        data = parse_tool_result(result)`n        assert data["success"] is True
        data = parse_tool_result(result)`n        assert data["size"] > 1024 * 1024
        assert "content" not in result.content  # Should not include large content

    @pytest.mark.asyncio
    async def test_get_file_info_nonexistent(self, temp_dir):
        """Test getting info for non-existent file."""
        nonexistent = temp_dir / "nonexistent.txt"
        result = await get_file_info.run({"path": str(nonexistent)})

        data = parse_tool_result(result)`n        assert data["success"] is False
        assert "not found" in result.content["error"].lower()


class TestEditFile:
    """Test the edit_file function."""

    @pytest.mark.asyncio
    async def test_edit_file_success(self, temp_file):
        """Test successful file editing."""
        original_content = "Hello, World!\nThis is a test file."
        temp_file.write_text(original_content)

        result = await edit_file(str(temp_file), "World", "Universe")

        assert result["success"] is True
        assert "Successfully edited file" in result["message"]
        assert result["occurrences_replaced"] == 1
        assert result["file_size_before"] == len(original_content)

        # Check the file content was actually changed
        new_content = temp_file.read_text()
        assert "Hello, Universe!" in new_content
        assert "World" not in new_content

    @pytest.mark.asyncio
    async def test_edit_file_multiple_occurrences(self, temp_file):
        """Test editing file with multiple occurrences of the same text."""
        original_content = "test test test"
        temp_file.write_text(original_content)

        result = await edit_file(str(temp_file), "test", "example")

        assert result["success"] is True
        assert result["occurrences_replaced"] == 3

        new_content = temp_file.read_text()
        assert new_content == "example example example"

    @pytest.mark.asyncio
    async def test_edit_file_empty_replacement(self, temp_file):
        """Test editing file with empty replacement (deletion)."""
        original_content = "Hello, World!\nThis is a test."
        temp_file.write_text(original_content)

        result = await edit_file(str(temp_file), "World!\n", "")

        assert result["success"] is True
        assert result["occurrences_replaced"] == 1

        new_content = temp_file.read_text()
        assert new_content == "Hello, This is a test."

    @pytest.mark.asyncio
    async def test_edit_file_not_found(self, temp_dir):
        """Test editing a non-existent file."""
        nonexistent = temp_dir / "nonexistent.txt"

        result = await edit_file(str(nonexistent), "old", "new")

        assert result["success"] is False
        assert "not found" in result["error"]

    @pytest.mark.asyncio
    async def test_edit_file_directory_as_file(self, temp_dir):
        """Test attempting to edit a directory as a file."""
        result = await edit_file(str(temp_dir), "old", "new")

        assert result["success"] is False
        assert "not a file" in result["error"]

    @pytest.mark.asyncio
    async def test_edit_file_empty_old_string(self, temp_file):
        """Test editing with empty old_string."""
        temp_file.write_text("content")

        result = await edit_file(str(temp_file), "", "new")

        assert result["success"] is False
        assert "old_string cannot be empty" in result["error"]

    @pytest.mark.asyncio
    async def test_edit_file_text_not_found(self, temp_file):
        """Test editing when the text to replace is not found."""
        temp_file.write_text("Hello, World!")

        result = await edit_file(str(temp_file), "Universe", "Galaxy")

        assert result["success"] is False
        assert "not found in file" in result["error"]

    @pytest.mark.asyncio
    async def test_edit_file_binary_content(self, temp_file):
        """Test attempting to edit a binary file."""
        # Write binary data
        temp_file.write_bytes(b'\xff\xfe\xfd\xfc')

        result = await edit_file(str(temp_file), "old", "new")

        assert result["success"] is False
        assert "not valid UTF-8 text" in result["error"]

    @pytest.mark.asyncio
    async def test_edit_file_backup_creation(self, temp_file):
        """Test that backup files are created during editing."""
        original_content = "Original content"
        temp_file.write_text(original_content)

        result = await edit_file(str(temp_file), "Original", "Modified")

        assert result["success"] is True
        # Backup should be cleaned up after successful edit
        backup_path = temp_file.with_suffix(temp_file.suffix + '.backup')
        assert not backup_path.exists()  # Should be cleaned up

    @pytest.mark.asyncio
    async def test_edit_file_no_changes(self, temp_file):
        """Test editing with identical old and new strings."""
        original_content = "test content"
        temp_file.write_text(original_content)

        result = await edit_file(str(temp_file), "test", "test")

        assert result["success"] is True
        assert result["occurrences_replaced"] == 1

        # Content should be unchanged
        new_content = temp_file.read_text()
        assert new_content == original_content
